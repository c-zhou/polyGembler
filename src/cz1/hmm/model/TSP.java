package cz1.hmm.model;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Random;

import cz1.util.IO;

public class TSP {
	// a lower triangular matrix
	public static String CONCORDE_PATH = "old_home/sw/TSP_solver";
	private final double[][] distance;
	private final int tsp_size;
	private String tmpdir = 
			System.getProperty("java.io.tmpdir");
	private int[] solution;
	
	public TSP(double[][] distance) {
		this.distance = distance;
		this.tsp_size = this.distance.length+1;
		this.write_TSPLIB();
		this.tsp_CONCORDE();
	}
	
	public TSP(double[][] distance,
			String tmpdir) {
		this.distance = distance;
		this.tmpdir = tmpdir;
		this.tsp_size = this.distance.length+1;
		this.write_TSPLIB();
		this.tsp_CONCORDE();
	}
	
	private void write_TSPLIB() {
		// write TSPLIB formatted file
		try {
			BufferedWriter bw = IO.getBufferedWriter(
					tmpdir+"/tmp_TSPLIB.tsp");
			bw.write("NAME: TSP\n");
			bw.write("COMMENT: Generated by write_TSPLIB (polymap class TSP)\n");
			bw.write("TYPE: TSP\n");
			bw.write("DIMENSION: "+(this.distance.length+1)+"\n");
			bw.write("EDGE_WEIGHT_TYPE: EXPLICIT\n");
			bw.write("EDGE_WEIGHT_FORMAT: UPPER_ROW\n");
			bw.write("EDGE_WEIGHT_SECTION\n");
			int n = this.tsp_size-1;
			double max_d = 0;
			for(int i=0; i<n; i++) 
				for(int j=i; j<n; j++)
					if(distance[j][i]>max_d)
						max_d = distance[j][i];
			final double precision = Math.min(1e6, n<10 ?
                    Math.pow(10,Math.floor(Math.log10(Math.pow(2, 15)/max_d))) :
                            Math.pow(10,Math.floor(Math.log10(Integer.MAX_VALUE/max_d))));
			for(int i=0; i<n; i++) 
				for(int j=i; j<n; j++)
					bw.write((int)(distance[j][i]*precision)+"\n");
			bw.write("EOF");
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	private void tsp_CONCORDE() {
		// solve TSP with concorde
		String[] commands = new String[] {
				CONCORDE_PATH+"/concorde "+tmpdir+"/tmp_TSPLIB.tsp"};
		String[] runnable;
		for(int i=0; i<commands.length; i++) {
			//System.out.println(commands[i]);
			runnable = new String[]{"bash","-c",commands[i]};
			try {
				Runtime.getRuntime().exec(runnable).waitFor();
			} catch (InterruptedException | IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		try {
			BufferedReader br = IO.getBufferedReader(tmpdir+"/tmp_TSPLIB.sol");
			br.readLine();
			solution = new int[this.tsp_size];
			String line;
			String[] s;
			int k=0;
			while( (line=br.readLine())!=null ) {
				s = line.split("\\s+");
				for(int i=0; i<s.length; i++)
					solution[k++] = Integer.parseInt(s[i]);
			}
			br.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public int[] solution() {
		return this.solution;
	}
	
	public static void main(String[] args) {
		int n = 299;
        double[][] distance = new double[n-1][];
        for(int i=0; i<distance.length; i++)
                distance[i] = new double[i+1];
        Random random = new Random();
        for(int i=0; i<n-1; i++)
                for(int j=i; j<n-1; j++)
                        distance[j][i] = random.nextDouble();
        TSP tsp = new TSP(distance);
        int[] sol = tsp.solution();
        for(int i=0; i<sol.length; i++) {
                System.out.println(sol[i]);
        }
	}
}
